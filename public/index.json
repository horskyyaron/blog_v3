[{"content":"","date":null,"permalink":"//localhost:1313/tags/config/","section":"Tags","summary":"","title":"Config"},{"content":"","date":null,"permalink":"//localhost:1313/tags/docs/","section":"Tags","summary":"","title":"Docs"},{"content":"Queus vs Pub/Sub #As the journey of learning about microservice continues, there is a concept of async collaboration between services.\nWhy is that important? Async communication allows for long running process to not block the client. It allows for snappier, better user experience since we will update the client/UI immediately, and return the calculated answer later.\nE.g. sending the client an email. The user signs up, and as a part of the process we send the user an email. There shouldn\u0026rsquo;t be any reason for the user to wait until that email has been sent. So we immediately redirect him to the homepage while generating a job of \u0026ldquo;sending an email\u0026rdquo;.\nNow comes the interesting part, and the detail here lays in WHO should care about this event?\nIn this simple case, only the email service should care about it, and if there are number of instances of the email service, any instance taking care of the job is fair game. That also means that ONLY the email service should subscribe to these queue. If there will be more than one service, if one polls for the message, the other service will not know about it.\nIn case multiple services \u0026ldquo;care\u0026rdquo; that a user has just signed up, a different approach is needed. The pub\\sub.\nIn this scenario the Email service and Customer Service both care that a new user has just signed up. Thus they will both will be consumers of a publisher that will tell them \u0026ldquo;new user\u0026rdquo; has just signed up.\n","date":"22 November 2025","permalink":"//localhost:1313/posts/sqs-vs-sns/","section":"Thoughts and writings","summary":"","title":"Sqs vs Sns"},{"content":"","date":null,"permalink":"//localhost:1313/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"this is posts\n","date":null,"permalink":"//localhost:1313/posts/","section":"Thoughts and writings","summary":"","title":"Thoughts and writings"},{"content":"My name is Yaron ðŸ˜ƒ I\u0026rsquo;m a funny guy which likes to cook, program, watch anime, read books (at least aspiring to) and overall to enjoy life.\nThis is just a big rubber duck debugging experiment.\nIts an attempt to clarify my thoughts and solidify my learnings. I find the idea that - if you can\u0026rsquo;t really describe something in your own words, you don\u0026rsquo;t really understand it, at least not at a deep level - to be true.\nThus, this little piece of software was born.\n","date":null,"permalink":"//localhost:1313/","section":"Welcome!","summary":"","title":"Welcome!"},{"content":"YWS #The Goal: creating a local \u0026ldquo;aws-ish\u0026rdquo; so i can play with these tools locally before \u0026ldquo;commiting\u0026rdquo; to the tools in the cloud which costs money.\nWhy? This will help me learn about these subjects, implementing and creating is the best way to learn. also very fun :)\n","date":"20 November 2025","permalink":"//localhost:1313/posts/yws/","section":"Thoughts and writings","summary":"","title":"Yws"},{"content":"This is a ongoing summary of the book \u0026ldquo;Building Microservices\u0026rdquo; by Sam Neuman.\nChapter 1 - What are microservices #From the book:\nMicroservices are small, autonomous services that work together.\nBreaking it down we get:\nSmall - in terms of code base and team. Autonomous - separate entities, deployed as a independent service. Communication between services are through network calls.\nThoughts are made about what is exposed vs hidden.\nKey Benefits #Technology Heterogeneity #Since each service is independent, we can choose the right tools for the job, for example:\ndatabase language Resilience #One service going down won\u0026rsquo;t make the whole system crash. NOTE: the system should be ready for this cases and handle them correctly.\nScaling #With smaller services, in contrast to monolith, we can just scale the part of the system that requires more resources.\nEase of deployment #We can deploy just the service that changes were made in, not the whole system.\nOptimize for replaceability #The cost of replacing one service is not that expensive since it is small in size and complexity. And since requirements are being changed all the time, and new technology is being created all the time, the system must be ready to embrace changes! Microservices are optimize for that uncertainty\nChapter 2 - The Evolutionary Architect #The term \u0026ldquo;Architect\u0026rdquo; has problems in the world of software. It was borrowed from an existing profession when the architect has accountability for example: if the building collapsed, the architect is the responsible persona.\nBut with software, things change over time, all the time, so you can\u0026rsquo;t have a \u0026ldquo;correct\u0026rdquo; timeless solution, since the future is unknown.\nWhen we create documentation, and diagrams on diagrams describing the perfect system, that is a lie.\nWe should think of ourselves as \u0026lsquo;City planner\u0026rsquo; as we care about zones in the system.\nRequirements and resources are rapidly changing (money, technology)\nOnce our product reaches the client, we will reveal how the user actually uses the product, and what we thought will be the main part of the system, might not be, thus we need to differently allocate our resources.\nWe should plan to allow for changes.\nAvoid over specifying things.\nthe system should be habitable for developers to\nWe should worry less about what happen inside the zones and more between the zones. How do they talk to each other.\nPrincipled approach #In Microservices we have many decisions we can make: database, language, this framework or the other.\nWhat should we do then? Framing\nWe should set principles and practices.\nPrinciples - set of rules we made in order to achieve some larger goal. Practices - how we ensure our principles are being carried out. A set of detailed practice guidance for preforming a task.\nDefining the required standard - what is a good citizen?\nmonitoring (system health, push vs pull approaches) interfaces. (HTTP, verbs or nouns? pagination resources? Versioning of endpoint?) safety. Chapter 3 - How to model services #How to think about the boundaries of our microservices.\nWhat makes a good service? # loosely coupled high in cohesion loose coupling #A Change in one service does not require a change in another.\nA loosely coupled service knows as little as it needs about services it collaborates with.\nThus, we\u0026rsquo;ll probably want to limit the number of different calls from one service to another. This will reduce the change for tight coupling.\nHigh cohesion #Related behavior will sit together while different behavior sit elsewhere.\nSo we need to find boundaries in our problem domain that will help ensure that services of related behavior sits together.\nThe bounded context #Any domain consists of multiple bounded contexts. Each has its own explicit interface, deciding what to share with other contexts.\nIn Domain-Driven-Design book, Evans uses the metaphor of a cell.\ncell can exist because their membraned define what is in and out and determine what can pass\nExample of bounded context, Warehouse department and Finance department.\nShared and hidden models #A warehouse department has knowledge that only interest himself, e.g. number of forklifts it has. But it also has knowledge that interest other services such as the finance department say list of the inventory.\nThus, the stock item becomes a shared model.\nBut the stock item in the warehouse context can have a representation different that one in the finance team. So there is an internal representation and external representation .\nA simple example:\nSay a shared model is user:\n{ \u0026#34;id\u0026#34;: \u0026#34;u123\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Yaron\u0026#34; } Authentication service internal representation:\n{ \u0026#34;userId\u0026#34;: \u0026#34;u123\u0026#34;, \u0026#34;fullName\u0026#34;: \u0026#34;Yaron Horsky\u0026#34;, \u0026#34;passwordHash\u0026#34;: \u0026#34;6fsd09dfj0932fjsd9f...\u0026#34;, \u0026#34;lastLoginAt\u0026#34;: \u0026#34;2025-11-20T10:00:00Z\u0026#34;, \u0026#34;failedLoginAttempts\u0026#34;: 3 } Notification service representation:\n{ \u0026#34;id\u0026#34;: \u0026#34;u123\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Yaron\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;yaron@example.com\u0026#34;, \u0026#34;emailOptIn\u0026#34;: true, \u0026#34;preferredLanguage\u0026#34;: \u0026#34;en\u0026#34; } Sometimes models can mean very different things depending on the context being used. For example Order:\nPayment Service context:\n{ \u0026#34;orderId\u0026#34;: \u0026#34;o123\u0026#34;, \u0026#34;totalAmount\u0026#34;: 124.90, \u0026#34;currency\u0026#34;: \u0026#34;USD\u0026#34;, \u0026#34;paymentStatus\u0026#34;: \u0026#34;PENDING\u0026#34; } Order Service context:\n{ \u0026#34;orderId\u0026#34;: \u0026#34;o123\u0026#34;, \u0026#34;customerId\u0026#34;: \u0026#34;c1\u0026#34;, \u0026#34;items\u0026#34;: [ { \u0026#34;sku\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ], \u0026#34;status\u0026#34;: \u0026#34;PLACED\u0026#34; } Shipping Service context\n{ \u0026#34;orderId\u0026#34;: \u0026#34;o123\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;street\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;IL\u0026#34; }, \u0026#34;weight\u0026#34;: 5.4, \u0026#34;shippingStatus\u0026#34;: \u0026#34;READY_TO_SHIP\u0026#34; } Premature decomposition #Premature decomposition can be costly. It is much easier to start with one code base and then split it than thinking ahead and split first.\nBusiness capabilities #We should think about context capabilities and not data that is shared.\nE.g an Ordering Service, these are some capabilities that interests us:\ncreating an order validate item availability apply business rules (discount, limits) change order state etc.. It exposes behaviors like:\nPOST /orders/validate POST /orders/confirm POST /orders/cancel This is a bounded context. The order data is not the main issue, but the capabilities of the service are.\nVS the anemic version, a CRUD version of the same Ordering Service:\nGET /orders/:id POST /orders PUT /orders/:id DELETE /orders/:id This is basically db with a wrapper.\nWhy this is bad?\nother services needs to implement the business rules high coupling: the one that writes the data controls behavior the core is the data, not the capabilities Communication in terms of business concepts #Changes are often about changes the business wants to make to how the system behaves. We are changing capabilities exposed to our customers.\nIf the system is decomposed by bounded context of our domain, changes are local and isolated.\nThus its important to think of the communication in terms of business concepts.\nIt can be useful to think of forms being sent between these microservices, much as forms are sent around an organization.\nAn example of form passing - Loan Application\nLoan application Service -\u0026gt; credit check service -\u0026gt; risk service -\u0026gt; approval service -\u0026gt; payout service\nChapter 4 - Integration #Getting integration right is key to make microservices hold their benefits, otherwise a disaster is coming.\nWhat is the best integration technology? # avoid breaking changes. e.g. some ms add a new field to a piece of data it sends, existing consumers shouldn\u0026rsquo;t be impacted. Technology-Agnostic API - since changes are coming, this is a fact, it is important that the communication between microservices won\u0026rsquo;t need major changes. Make services simple for consumers - we would like to allow the consumers to choose whatever tech they want, such that the communication with this service won\u0026rsquo;t affect that choice or restrict it. Hide implementation detail - consumers shouldn\u0026rsquo;t be bound to the service internal implementation. This is tightly coupled. Any technology that makes us expose these details should be avoided. The shared database #This is bad!\nAllowing external parties view internal implementation details. Changes to the schema breaks consumers. Consumers are bound to specific technology choice (relational db for example) (tightly coupled) where is the logic? logic is spread across multiple consumers. (no cohesion) Database integration makes it easy to share data, but doesn\u0026rsquo;t share behavior.\nSync vs Async #Async can be useful for long running tasks. Firing requests and assuming they worked allows us to update the UI quickly give the user a better experience, and later updating when the tasks end and we get the response.\nThere are 2 different types of collaboration:\nrequest/response event-based Event based is saying that \u0026ldquo;something appended\u0026rdquo; and the parties that care about it will do stuff accordingly.\nAnother benefit of event-based collaboration is that it is highly decoupled.\nOrchestration vs choreography #Complex system requires processes that spans over multiple parts of the system, more than the boundary of one service.\nOrchestration: relying on one central point which guide and drive the process. Like the conductor in an orchestra.\nChoreography: we tell each part of its job, and let it work out the details. Like a ballet dancer reacting to others around them.\nExample scenario:\nWhen a new user is created, we\nsend an email we post a thank you note Each of these is handled through a different service: email service and post service\nDownside of Orchestration is that it becomes too much of a center.\nWith Choreography approach, the customer service emit an event in an async manner saying that a new customer has been created The downside here is that the explicit process is implicit in our solution, meaning we need to somehow track to tell if the process has indeed finished successfully. A good solution here is to build a monitoring system that explicitly matches the business process.\nRemote Procedure calls (RPC) #I need to read more about it.\nREST #REpresentational State Transfer (REST) is in a architectural style inspired by the Web.\nResource - a thing that the service know about (like a Customer) the server create different representation of this resource on a request. How this resource is exposed is decouple from how it look internally.\nE.g. a client ask for a JSON representation while the resource internally is being kept in a relational db.\nREST and HTTP #HTTP protocol goes well with REST style, e.g. http verbs. HTTP also bring a lot of tooling with it. Some allows for better security.\nFor server-to-server communication if extremely low latency or small size is important, we will use TCP instead of http.\nOverall REST over HTTP is the default choice for service-to-service communication today.\nImplementing Async event-based collaboration #Technology choices #Two main parts:\na way to emit events a way for consumers to find out these events happened. One solution - a massage broker. Like RabbitMQ. Keep your middleware (where the messages pass) dumb, keep the logic at the ends.\nComplexities #You need to think about failures and how to treat them, for example, say the response comes back, does it return to the same node it came out of? What if that node is down? It Is important to have monitoring and the use of correlation IDs is recommended so we can track a sequence of requests across services.\nServices as state machines #We want to avoid dumb services that are CRUD wrappers. Having the life cycle of key domain concept explicit modeled is pretty powerful.\nAccess by reference #We need to know that the microservices for Customer hold all of the entity lifecycle. This also needs to be the source of truth for the customer.\nIt is possible that after we ask for a Customer, while it is in our hands, the entity has changed. If we avoid requesting data more than we need, our system will be much more efficient.\nExample: we ask the email service to send an email when an order has been shipped.\nbad: we can send the email service the order details with the customer information. if the email is pulling these from a queue, while the requests waits there, things change. good: a better alternative is to send URI for the Customer and Order resources and the email service will look them up when it is time.\nVersioning # postpone until you must semantic versioning MAJOR.MINOR.PATCH MAJOR change - breaking changes has been made. MINOR change - new functionality has been added, should support backwards compatibility PATCH change - bug fix for existing features.\ncoexist different endpoints gradually moving into a new service. Expand and contract pattern. We expand with a new service, once everyone is using the new one, we contract and remove the old service One way is adding version number to the URI. e.g. /v1/customer/ or /v2/customer\nusing multiple concurrent service versions User Interface (UI) #The user can interact with our application through different kinds of devices: mobile phone, web, tablet, computer.\nEach device has constraint, e.g. you can\u0026rsquo;t right click on a phone for example. Or some activities are battery draining.\nThus, there is a need to handle those differences between each type of interface\nbackends for frontends #One way to handle chatty interface is to have one endpoint in a gateway that will fetch all of the data from the different services\nanother model is to have a server for each user interface\nMobile app - mobile backend website - website backend helpdesk - helpdesk backend\nif there is an api authentication and auth layer, we can put this layer for all backends before it reaches them\nIntegrating 3rd party software #Author advice, if it is unique for the business that we are building, build it, otherwise there is no reason for you to develop, just buy the current existing tool for the job. Examples: CRM, CMS\nCustomization #Sometimes, these services requires heavy customization Find the core concept that are important to your domain, it will front the CRM expose simple REST API and we can integrate using this service this is a called a facade\n","date":"19 November 2025","permalink":"//localhost:1313/posts/learning-about-microservices/","section":"Thoughts and writings","summary":"","title":"Learning About Microservices"},{"content":"Intro #This is a list of articles that I loved. Maybe in the future I\u0026rsquo;ll sort these by subject :)\nArticles I loved # Mastering Programming - Kent Beck Build your own Database - Nanda Syahrasyad ","date":"18 November 2025","permalink":"//localhost:1313/posts/articles_i_loved/","section":"Thoughts and writings","summary":"","title":"Articles I Loved"},{"content":"","date":null,"permalink":"//localhost:1313/categories/","section":"Categories","summary":"","title":"Categories"}]